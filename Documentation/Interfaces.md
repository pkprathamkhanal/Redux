There are five main interfaces that each problem should implement to be a complete problem. Once these interfaces are implemented, they are automatically accessible with the existing API. Templates for all of the interfaces can be generated by going to the [main site](https://redux.portneuf.cose.isu.edu/), typing in the name of your problem, and clicking "add new problem". 

## String Fields
All interfaces have several string fields which describe the purposes and sources of that implementation.

## IProblem
The `IProblem` interface is the main interface when implementing a problem. It has three generic types, a `ISolver`, `IVerifier`, and an `IVisualization`. While a problem can have several of each of these, it needs to have a default implementation of each. An `IProblem` should have a constructor that builds a problem out of a string, and a constructor that builds a default problem. If your problem does not have a visualization, then the class `DummyVisualization` can be used. 

## IVerifier
The `IVerifier` interface is a verifier for its problem type. It needs to implement a boolean method `verify` that takes in the problem, a string representing the solution called a certificate, and returns if the certificate was a solution.

## ISolver
An `ISolver` needs a method that takes an instance of a problem, and returns the solution to that problem. It optionally can implement a `GetSteps` method that returns the first 99 steps as a list of string. Currently these strings should be in the same format as a solution certificate.

## IVisualization
An `IVisualization` needs a method `visualize` that takes a problem and returns and `API_JSON` object that represents a visualization. Currently there are two visualizations implemented, one for boolean satisfiability problems, `API_SAT` and one for graph problems, `API_graph`. These both are the visualiation types `Boolean Satisfiability` and `Graph D3` respectively. This visualization type should be set in the feild `visualizationType`. 

An `IVisualization` may also implement the method `SolvedVisualization` that also takes in a solution, and highlights parts of the problem that are in the solution.

An `Iisualization` may also implement the method `StepsVisualization` which takes in a list of solution certificates and returns a list of `API_JSON` that visualizes each step.

## IReduction
The `IReduction` interface represents a reduction from one IProblem to another IProblem. This interface takes a starting problem, assigned to reductionFrom, and a resulting problem, assigned to reductionTo. It should have three interfaces, one with no arguments that constructs a default instance of the starting problem, one that takes an instance string of the starting problem and one that takes an initialized problem. These should all set the reduced resulting problem to reductionTo

An `IReduction` needs a `reduce` method that makes the resulting problem from the starting problem. This function may also make a `gadgets` object.

An `IReduction` should have a `mapSolutions` method that takes a solution certificate of the starting problem, and returns an equivalent solution certificate of the resulting problem.

An `IReduction` may also have `gadgets` field which is a mapping from a list of ids in the starting problem to a list of ids in the resulting problem that are made out of each other. Ids should be generated uniquely from each problem. 